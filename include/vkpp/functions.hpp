// Copyright (c) 2017 nyorain
// Distributed under the Boost Software License, Version 1.0.
// See accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt

// Automaitcally generated vulkan header, see nyorain/vkpp
// Do not edit manually, rather edit the codegen files.

#pragma once
#include <vkpp/fwd.hpp>
#include <vkpp/enums.hpp>
#include <vkpp/structs.hpp>
#include <vkpp/call.hpp>
#include <vkpp/span.hpp>
#include <vkpp/flags.hpp>

#include <vector>
#include <vulkan/vulkan.h>

// Generated for vulkan version: 1.1.107
#if !defined(VK_VERSION_1_1) || 107 > VK_HEADER_VERSION
	#error "vulkan.h version too old, does not match generated version"
#endif

#define VEC_FUNC(T, CT, F, ...) \
	std::vector<T> ret; \
	CT count = 0u; \
	if(!error::success(VKPP_CALL(F(__VA_ARGS__)))) return ret; \
	ret.resize(count); \
	VKPP_CALL(F(__VA_ARGS__)); \
	return ret;

#define VEC_FUNC_VOID(T, CT, F, ...) \
	std::vector<T> ret; \
	CT count = 0u; \
	VKPP_DISPATCH(F(__VA_ARGS__)); \
	ret.resize(count); \
	F(__VA_ARGS__); \
	return ret;

#define VEC_FUNC_RET(T, C, F, ...) \
	std::vector<T> ret; \
	ret.resize(C); \
	VKPP_CALL(F(__VA_ARGS__)); \
	return ret;

#define VEC_FUNC_RET_VOID(T, C, F, ...) \
	std::vector<T> ret; \
	ret.resize(C); \
	VKPP_DISPATCH(F(__VA_ARGS__)); \
	return ret;

namespace vk {

inline uint32_t enumerateInstanceVersion(){ uint32_t ret = {}; VKPP_CALL(vkEnumerateInstanceVersion((uint32_t*)(&ret))); return ret; }
inline Result bindBufferMemory2(Device device, uint32_t bindInfoCount, const BindBufferMemoryInfo& pBindInfos){ return static_cast<Result>(VKPP_CALL(vkBindBufferMemory2((VkDevice)(device), bindInfoCount, (const VkBindBufferMemoryInfo*)(&pBindInfos)))); }
inline Result bindBufferMemory2(Device device, Span<const BindBufferMemoryInfo> pBindInfos){ return VKPP_CALL(vkBindBufferMemory2((VkDevice)(device), pBindInfos.size(), (const VkBindBufferMemoryInfo*)(pBindInfos.data()))); }
inline Result bindBufferMemory2KHR(Device device, uint32_t bindInfoCount, const BindBufferMemoryInfo& pBindInfos){ return static_cast<Result>(VKPP_CALL(vkBindBufferMemory2((VkDevice)(device), bindInfoCount, (const VkBindBufferMemoryInfo*)(&pBindInfos)))); }
inline Result bindBufferMemory2KHR(Device device, Span<const BindBufferMemoryInfo> pBindInfos){ return VKPP_CALL(vkBindBufferMemory2((VkDevice)(device), pBindInfos.size(), (const VkBindBufferMemoryInfo*)(pBindInfos.data()))); }
inline Result bindImageMemory2(Device device, uint32_t bindInfoCount, const BindImageMemoryInfo& pBindInfos){ return static_cast<Result>(VKPP_CALL(vkBindImageMemory2((VkDevice)(device), bindInfoCount, (const VkBindImageMemoryInfo*)(&pBindInfos)))); }
inline Result bindImageMemory2(Device device, Span<const BindImageMemoryInfo> pBindInfos){ return VKPP_CALL(vkBindImageMemory2((VkDevice)(device), pBindInfos.size(), (const VkBindImageMemoryInfo*)(pBindInfos.data()))); }
inline Result bindImageMemory2KHR(Device device, uint32_t bindInfoCount, const BindImageMemoryInfo& pBindInfos){ return static_cast<Result>(VKPP_CALL(vkBindImageMemory2((VkDevice)(device), bindInfoCount, (const VkBindImageMemoryInfo*)(&pBindInfos)))); }
inline Result bindImageMemory2KHR(Device device, Span<const BindImageMemoryInfo> pBindInfos){ return VKPP_CALL(vkBindImageMemory2((VkDevice)(device), pBindInfos.size(), (const VkBindImageMemoryInfo*)(pBindInfos.data()))); }
inline PeerMemoryFeatureFlags getDeviceGroupPeerMemoryFeatures(Device device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex){ PeerMemoryFeatureFlags ret = {}; VKPP_DISPATCH(vkGetDeviceGroupPeerMemoryFeatures((VkDevice)(device), heapIndex, localDeviceIndex, remoteDeviceIndex, (VkPeerMemoryFeatureFlags*)(&ret))); return ret; }
inline PeerMemoryFeatureFlags getDeviceGroupPeerMemoryFeaturesKHR(Device device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex){ PeerMemoryFeatureFlags ret = {}; VKPP_DISPATCH(vkGetDeviceGroupPeerMemoryFeatures((VkDevice)(device), heapIndex, localDeviceIndex, remoteDeviceIndex, (VkPeerMemoryFeatureFlags*)(&ret))); return ret; }
inline void cmdSetDeviceMask(CommandBuffer commandBuffer, uint32_t deviceMask){ return VKPP_DISPATCH(vkCmdSetDeviceMask((VkCommandBuffer)(commandBuffer), deviceMask)); }
inline void cmdSetDeviceMaskKHR(CommandBuffer commandBuffer, uint32_t deviceMask){ return VKPP_DISPATCH(vkCmdSetDeviceMask((VkCommandBuffer)(commandBuffer), deviceMask)); }
inline void cmdDispatchBase(CommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ){ return VKPP_DISPATCH(vkCmdDispatchBase((VkCommandBuffer)(commandBuffer), baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)); }
inline void cmdDispatchBaseKHR(CommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ){ return VKPP_DISPATCH(vkCmdDispatchBase((VkCommandBuffer)(commandBuffer), baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)); }
inline Result enumeratePhysicalDeviceGroups(Instance instance, uint32_t& pPhysicalDeviceGroupCount, PhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties = {}){ return static_cast<Result>(VKPP_CALL(vkEnumeratePhysicalDeviceGroups((VkInstance)(instance), (uint32_t*)(&pPhysicalDeviceGroupCount), (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties)))); }
inline std::vector<PhysicalDeviceGroupProperties> enumeratePhysicalDeviceGroups(Instance instance){ VEC_FUNC(PhysicalDeviceGroupProperties, uint32_t, vkEnumeratePhysicalDeviceGroups, (VkInstance)(instance), &count, (VkPhysicalDeviceGroupProperties*)(ret.data()));  }
inline Result enumeratePhysicalDeviceGroupsKHR(Instance instance, uint32_t& pPhysicalDeviceGroupCount, PhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties = {}){ return static_cast<Result>(VKPP_CALL(vkEnumeratePhysicalDeviceGroups((VkInstance)(instance), (uint32_t*)(&pPhysicalDeviceGroupCount), (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties)))); }
inline std::vector<PhysicalDeviceGroupProperties> enumeratePhysicalDeviceGroupsKHR(Instance instance){ VEC_FUNC(PhysicalDeviceGroupProperties, uint32_t, vkEnumeratePhysicalDeviceGroups, (VkInstance)(instance), &count, (VkPhysicalDeviceGroupProperties*)(ret.data()));  }
inline MemoryRequirements2 getImageMemoryRequirements2(Device device, const ImageMemoryRequirementsInfo2& pInfo){ MemoryRequirements2 ret = {}; VKPP_DISPATCH(vkGetImageMemoryRequirements2((VkDevice)(device), (const VkImageMemoryRequirementsInfo2*)(&pInfo), (VkMemoryRequirements2*)(&ret))); return ret; }
inline MemoryRequirements2 getImageMemoryRequirements2KHR(Device device, const ImageMemoryRequirementsInfo2& pInfo){ MemoryRequirements2 ret = {}; VKPP_DISPATCH(vkGetImageMemoryRequirements2((VkDevice)(device), (const VkImageMemoryRequirementsInfo2*)(&pInfo), (VkMemoryRequirements2*)(&ret))); return ret; }
inline MemoryRequirements2 getBufferMemoryRequirements2(Device device, const BufferMemoryRequirementsInfo2& pInfo){ MemoryRequirements2 ret = {}; VKPP_DISPATCH(vkGetBufferMemoryRequirements2((VkDevice)(device), (const VkBufferMemoryRequirementsInfo2*)(&pInfo), (VkMemoryRequirements2*)(&ret))); return ret; }
inline MemoryRequirements2 getBufferMemoryRequirements2KHR(Device device, const BufferMemoryRequirementsInfo2& pInfo){ MemoryRequirements2 ret = {}; VKPP_DISPATCH(vkGetBufferMemoryRequirements2((VkDevice)(device), (const VkBufferMemoryRequirementsInfo2*)(&pInfo), (VkMemoryRequirements2*)(&ret))); return ret; }
inline void getImageSparseMemoryRequirements2(Device device, const ImageSparseMemoryRequirementsInfo2& pInfo, uint32_t& pSparseMemoryRequirementCount, SparseImageMemoryRequirements2* pSparseMemoryRequirements = {}){ return VKPP_DISPATCH(vkGetImageSparseMemoryRequirements2((VkDevice)(device), (const VkImageSparseMemoryRequirementsInfo2*)(&pInfo), (uint32_t*)(&pSparseMemoryRequirementCount), (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements))); }
inline std::vector<SparseImageMemoryRequirements2> getImageSparseMemoryRequirements2(Device device, const ImageSparseMemoryRequirementsInfo2& pInfo){ VEC_FUNC_VOID(SparseImageMemoryRequirements2, uint32_t, vkGetImageSparseMemoryRequirements2, (VkDevice)(device), (const VkImageSparseMemoryRequirementsInfo2*)(&pInfo), &count, (VkSparseImageMemoryRequirements2*)(ret.data()));  }
inline void getImageSparseMemoryRequirements2KHR(Device device, const ImageSparseMemoryRequirementsInfo2& pInfo, uint32_t& pSparseMemoryRequirementCount, SparseImageMemoryRequirements2* pSparseMemoryRequirements = {}){ return VKPP_DISPATCH(vkGetImageSparseMemoryRequirements2((VkDevice)(device), (const VkImageSparseMemoryRequirementsInfo2*)(&pInfo), (uint32_t*)(&pSparseMemoryRequirementCount), (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements))); }
inline std::vector<SparseImageMemoryRequirements2> getImageSparseMemoryRequirements2KHR(Device device, const ImageSparseMemoryRequirementsInfo2& pInfo){ VEC_FUNC_VOID(SparseImageMemoryRequirements2, uint32_t, vkGetImageSparseMemoryRequirements2, (VkDevice)(device), (const VkImageSparseMemoryRequirementsInfo2*)(&pInfo), &count, (VkSparseImageMemoryRequirements2*)(ret.data()));  }
inline void getPhysicalDeviceFeatures2(PhysicalDevice physicalDevice, PhysicalDeviceFeatures2& pFeatures){ return VKPP_DISPATCH(vkGetPhysicalDeviceFeatures2((VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceFeatures2*)(&pFeatures))); }
inline void getPhysicalDeviceFeatures2KHR(PhysicalDevice physicalDevice, PhysicalDeviceFeatures2& pFeatures){ return VKPP_DISPATCH(vkGetPhysicalDeviceFeatures2((VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceFeatures2*)(&pFeatures))); }
inline PhysicalDeviceProperties2 getPhysicalDeviceProperties2(PhysicalDevice physicalDevice){ PhysicalDeviceProperties2 ret = {}; VKPP_DISPATCH(vkGetPhysicalDeviceProperties2((VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceProperties2*)(&ret))); return ret; }
inline PhysicalDeviceProperties2 getPhysicalDeviceProperties2KHR(PhysicalDevice physicalDevice){ PhysicalDeviceProperties2 ret = {}; VKPP_DISPATCH(vkGetPhysicalDeviceProperties2((VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceProperties2*)(&ret))); return ret; }
inline FormatProperties2 getPhysicalDeviceFormatProperties2(PhysicalDevice physicalDevice, Format format){ FormatProperties2 ret = {}; VKPP_DISPATCH(vkGetPhysicalDeviceFormatProperties2((VkPhysicalDevice)(physicalDevice), static_cast<VkFormat>(format), (VkFormatProperties2*)(&ret))); return ret; }
inline FormatProperties2 getPhysicalDeviceFormatProperties2KHR(PhysicalDevice physicalDevice, Format format){ FormatProperties2 ret = {}; VKPP_DISPATCH(vkGetPhysicalDeviceFormatProperties2((VkPhysicalDevice)(physicalDevice), static_cast<VkFormat>(format), (VkFormatProperties2*)(&ret))); return ret; }
inline ImageFormatProperties2 getPhysicalDeviceImageFormatProperties2(PhysicalDevice physicalDevice, const PhysicalDeviceImageFormatInfo2& pImageFormatInfo){ ImageFormatProperties2 ret = {}; VKPP_CALL(vkGetPhysicalDeviceImageFormatProperties2((VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceImageFormatInfo2*)(&pImageFormatInfo), (VkImageFormatProperties2*)(&ret))); return ret; }
inline ImageFormatProperties2 getPhysicalDeviceImageFormatProperties2KHR(PhysicalDevice physicalDevice, const PhysicalDeviceImageFormatInfo2& pImageFormatInfo){ ImageFormatProperties2 ret = {}; VKPP_CALL(vkGetPhysicalDeviceImageFormatProperties2((VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceImageFormatInfo2*)(&pImageFormatInfo), (VkImageFormatProperties2*)(&ret))); return ret; }
inline void getPhysicalDeviceQueueFamilyProperties2(PhysicalDevice physicalDevice, uint32_t& pQueueFamilyPropertyCount, QueueFamilyProperties2* pQueueFamilyProperties = {}){ return VKPP_DISPATCH(vkGetPhysicalDeviceQueueFamilyProperties2((VkPhysicalDevice)(physicalDevice), (uint32_t*)(&pQueueFamilyPropertyCount), (VkQueueFamilyProperties2*)(pQueueFamilyProperties))); }
inline std::vector<QueueFamilyProperties2> getPhysicalDeviceQueueFamilyProperties2(PhysicalDevice physicalDevice){ VEC_FUNC_VOID(QueueFamilyProperties2, uint32_t, vkGetPhysicalDeviceQueueFamilyProperties2, (VkPhysicalDevice)(physicalDevice), &count, (VkQueueFamilyProperties2*)(ret.data()));  }
inline void getPhysicalDeviceQueueFamilyProperties2KHR(PhysicalDevice physicalDevice, uint32_t& pQueueFamilyPropertyCount, QueueFamilyProperties2* pQueueFamilyProperties = {}){ return VKPP_DISPATCH(vkGetPhysicalDeviceQueueFamilyProperties2((VkPhysicalDevice)(physicalDevice), (uint32_t*)(&pQueueFamilyPropertyCount), (VkQueueFamilyProperties2*)(pQueueFamilyProperties))); }
inline std::vector<QueueFamilyProperties2> getPhysicalDeviceQueueFamilyProperties2KHR(PhysicalDevice physicalDevice){ VEC_FUNC_VOID(QueueFamilyProperties2, uint32_t, vkGetPhysicalDeviceQueueFamilyProperties2, (VkPhysicalDevice)(physicalDevice), &count, (VkQueueFamilyProperties2*)(ret.data()));  }
inline PhysicalDeviceMemoryProperties2 getPhysicalDeviceMemoryProperties2(PhysicalDevice physicalDevice){ PhysicalDeviceMemoryProperties2 ret = {}; VKPP_DISPATCH(vkGetPhysicalDeviceMemoryProperties2((VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceMemoryProperties2*)(&ret))); return ret; }
inline PhysicalDeviceMemoryProperties2 getPhysicalDeviceMemoryProperties2KHR(PhysicalDevice physicalDevice){ PhysicalDeviceMemoryProperties2 ret = {}; VKPP_DISPATCH(vkGetPhysicalDeviceMemoryProperties2((VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceMemoryProperties2*)(&ret))); return ret; }
inline void getPhysicalDeviceSparseImageFormatProperties2(PhysicalDevice physicalDevice, const PhysicalDeviceSparseImageFormatInfo2& pFormatInfo, uint32_t& pPropertyCount, SparseImageFormatProperties2* pProperties = {}){ return VKPP_DISPATCH(vkGetPhysicalDeviceSparseImageFormatProperties2((VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceSparseImageFormatInfo2*)(&pFormatInfo), (uint32_t*)(&pPropertyCount), (VkSparseImageFormatProperties2*)(pProperties))); }
inline std::vector<SparseImageFormatProperties2> getPhysicalDeviceSparseImageFormatProperties2(PhysicalDevice physicalDevice, const PhysicalDeviceSparseImageFormatInfo2& pFormatInfo){ VEC_FUNC_VOID(SparseImageFormatProperties2, uint32_t, vkGetPhysicalDeviceSparseImageFormatProperties2, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceSparseImageFormatInfo2*)(&pFormatInfo), &count, (VkSparseImageFormatProperties2*)(ret.data()));  }
inline void getPhysicalDeviceSparseImageFormatProperties2KHR(PhysicalDevice physicalDevice, const PhysicalDeviceSparseImageFormatInfo2& pFormatInfo, uint32_t& pPropertyCount, SparseImageFormatProperties2* pProperties = {}){ return VKPP_DISPATCH(vkGetPhysicalDeviceSparseImageFormatProperties2((VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceSparseImageFormatInfo2*)(&pFormatInfo), (uint32_t*)(&pPropertyCount), (VkSparseImageFormatProperties2*)(pProperties))); }
inline std::vector<SparseImageFormatProperties2> getPhysicalDeviceSparseImageFormatProperties2KHR(PhysicalDevice physicalDevice, const PhysicalDeviceSparseImageFormatInfo2& pFormatInfo){ VEC_FUNC_VOID(SparseImageFormatProperties2, uint32_t, vkGetPhysicalDeviceSparseImageFormatProperties2, (VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceSparseImageFormatInfo2*)(&pFormatInfo), &count, (VkSparseImageFormatProperties2*)(ret.data()));  }
inline void trimCommandPool(Device device, CommandPool commandPool, CommandPoolTrimFlags flags = {}){ return VKPP_DISPATCH(vkTrimCommandPool((VkDevice)(device), (VkCommandPool)(commandPool), static_cast<VkCommandPoolTrimFlags>(flags))); }
inline void trimCommandPoolKHR(Device device, CommandPool commandPool, CommandPoolTrimFlags flags = {}){ return VKPP_DISPATCH(vkTrimCommandPool((VkDevice)(device), (VkCommandPool)(commandPool), static_cast<VkCommandPoolTrimFlags>(flags))); }
inline Queue getDeviceQueue2(Device device, const DeviceQueueInfo2& pQueueInfo){ Queue ret = {}; VKPP_DISPATCH(vkGetDeviceQueue2((VkDevice)(device), (const VkDeviceQueueInfo2*)(&pQueueInfo), (VkQueue*)(&ret))); return ret; }
inline SamplerYcbcrConversion createSamplerYcbcrConversion(Device device, const SamplerYcbcrConversionCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ SamplerYcbcrConversion ret = {}; VKPP_CALL(vkCreateSamplerYcbcrConversion((VkDevice)(device), (const VkSamplerYcbcrConversionCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSamplerYcbcrConversion*)(&ret))); return ret; }
inline SamplerYcbcrConversion createSamplerYcbcrConversionKHR(Device device, const SamplerYcbcrConversionCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ SamplerYcbcrConversion ret = {}; VKPP_CALL(vkCreateSamplerYcbcrConversion((VkDevice)(device), (const VkSamplerYcbcrConversionCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSamplerYcbcrConversion*)(&ret))); return ret; }
inline void destroySamplerYcbcrConversion(Device device, SamplerYcbcrConversion ycbcrConversion = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroySamplerYcbcrConversion((VkDevice)(device), (VkSamplerYcbcrConversion)(ycbcrConversion), (const VkAllocationCallbacks*)(pAllocator))); }
inline void destroySamplerYcbcrConversionKHR(Device device, SamplerYcbcrConversion ycbcrConversion = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroySamplerYcbcrConversion((VkDevice)(device), (VkSamplerYcbcrConversion)(ycbcrConversion), (const VkAllocationCallbacks*)(pAllocator))); }
inline DescriptorUpdateTemplate createDescriptorUpdateTemplate(Device device, const DescriptorUpdateTemplateCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ DescriptorUpdateTemplate ret = {}; VKPP_CALL(vkCreateDescriptorUpdateTemplate((VkDevice)(device), (const VkDescriptorUpdateTemplateCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkDescriptorUpdateTemplate*)(&ret))); return ret; }
inline DescriptorUpdateTemplate createDescriptorUpdateTemplateKHR(Device device, const DescriptorUpdateTemplateCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ DescriptorUpdateTemplate ret = {}; VKPP_CALL(vkCreateDescriptorUpdateTemplate((VkDevice)(device), (const VkDescriptorUpdateTemplateCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkDescriptorUpdateTemplate*)(&ret))); return ret; }
inline void destroyDescriptorUpdateTemplate(Device device, DescriptorUpdateTemplate descriptorUpdateTemplate = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyDescriptorUpdateTemplate((VkDevice)(device), (VkDescriptorUpdateTemplate)(descriptorUpdateTemplate), (const VkAllocationCallbacks*)(pAllocator))); }
inline void destroyDescriptorUpdateTemplateKHR(Device device, DescriptorUpdateTemplate descriptorUpdateTemplate = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyDescriptorUpdateTemplate((VkDevice)(device), (VkDescriptorUpdateTemplate)(descriptorUpdateTemplate), (const VkAllocationCallbacks*)(pAllocator))); }
inline void updateDescriptorSetWithTemplate(Device device, DescriptorSet descriptorSet, DescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData){ return VKPP_DISPATCH(vkUpdateDescriptorSetWithTemplate((VkDevice)(device), (VkDescriptorSet)(descriptorSet), (VkDescriptorUpdateTemplate)(descriptorUpdateTemplate), (const void*)(pData))); }
inline void updateDescriptorSetWithTemplateKHR(Device device, DescriptorSet descriptorSet, DescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData){ return VKPP_DISPATCH(vkUpdateDescriptorSetWithTemplate((VkDevice)(device), (VkDescriptorSet)(descriptorSet), (VkDescriptorUpdateTemplate)(descriptorUpdateTemplate), (const void*)(pData))); }
inline ExternalBufferProperties getPhysicalDeviceExternalBufferProperties(PhysicalDevice physicalDevice, const PhysicalDeviceExternalBufferInfo& pExternalBufferInfo){ ExternalBufferProperties ret = {}; VKPP_DISPATCH(vkGetPhysicalDeviceExternalBufferProperties((VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceExternalBufferInfo*)(&pExternalBufferInfo), (VkExternalBufferProperties*)(&ret))); return ret; }
inline ExternalBufferProperties getPhysicalDeviceExternalBufferPropertiesKHR(PhysicalDevice physicalDevice, const PhysicalDeviceExternalBufferInfo& pExternalBufferInfo){ ExternalBufferProperties ret = {}; VKPP_DISPATCH(vkGetPhysicalDeviceExternalBufferProperties((VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceExternalBufferInfo*)(&pExternalBufferInfo), (VkExternalBufferProperties*)(&ret))); return ret; }
inline ExternalFenceProperties getPhysicalDeviceExternalFenceProperties(PhysicalDevice physicalDevice, const PhysicalDeviceExternalFenceInfo& pExternalFenceInfo){ ExternalFenceProperties ret = {}; VKPP_DISPATCH(vkGetPhysicalDeviceExternalFenceProperties((VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceExternalFenceInfo*)(&pExternalFenceInfo), (VkExternalFenceProperties*)(&ret))); return ret; }
inline ExternalFenceProperties getPhysicalDeviceExternalFencePropertiesKHR(PhysicalDevice physicalDevice, const PhysicalDeviceExternalFenceInfo& pExternalFenceInfo){ ExternalFenceProperties ret = {}; VKPP_DISPATCH(vkGetPhysicalDeviceExternalFenceProperties((VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceExternalFenceInfo*)(&pExternalFenceInfo), (VkExternalFenceProperties*)(&ret))); return ret; }
inline ExternalSemaphoreProperties getPhysicalDeviceExternalSemaphoreProperties(PhysicalDevice physicalDevice, const PhysicalDeviceExternalSemaphoreInfo& pExternalSemaphoreInfo){ ExternalSemaphoreProperties ret = {}; VKPP_DISPATCH(vkGetPhysicalDeviceExternalSemaphoreProperties((VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceExternalSemaphoreInfo*)(&pExternalSemaphoreInfo), (VkExternalSemaphoreProperties*)(&ret))); return ret; }
inline ExternalSemaphoreProperties getPhysicalDeviceExternalSemaphorePropertiesKHR(PhysicalDevice physicalDevice, const PhysicalDeviceExternalSemaphoreInfo& pExternalSemaphoreInfo){ ExternalSemaphoreProperties ret = {}; VKPP_DISPATCH(vkGetPhysicalDeviceExternalSemaphoreProperties((VkPhysicalDevice)(physicalDevice), (const VkPhysicalDeviceExternalSemaphoreInfo*)(&pExternalSemaphoreInfo), (VkExternalSemaphoreProperties*)(&ret))); return ret; }
inline DescriptorSetLayoutSupport getDescriptorSetLayoutSupport(Device device, const DescriptorSetLayoutCreateInfo& pCreateInfo){ DescriptorSetLayoutSupport ret = {}; VKPP_DISPATCH(vkGetDescriptorSetLayoutSupport((VkDevice)(device), (const VkDescriptorSetLayoutCreateInfo*)(&pCreateInfo), (VkDescriptorSetLayoutSupport*)(&ret))); return ret; }
inline DescriptorSetLayoutSupport getDescriptorSetLayoutSupportKHR(Device device, const DescriptorSetLayoutCreateInfo& pCreateInfo){ DescriptorSetLayoutSupport ret = {}; VKPP_DISPATCH(vkGetDescriptorSetLayoutSupport((VkDevice)(device), (const VkDescriptorSetLayoutCreateInfo*)(&pCreateInfo), (VkDescriptorSetLayoutSupport*)(&ret))); return ret; }

inline Instance createInstance(const InstanceCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ Instance ret = {}; VKPP_CALL(vkCreateInstance((const VkInstanceCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkInstance*)(&ret))); return ret; }
inline void destroyInstance(Instance instance = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyInstance((VkInstance)(instance), (const VkAllocationCallbacks*)(pAllocator))); }
inline Result enumeratePhysicalDevices(Instance instance, uint32_t& pPhysicalDeviceCount, PhysicalDevice* pPhysicalDevices = {}){ return static_cast<Result>(VKPP_CALL(vkEnumeratePhysicalDevices((VkInstance)(instance), (uint32_t*)(&pPhysicalDeviceCount), (VkPhysicalDevice*)(pPhysicalDevices)))); }
inline std::vector<PhysicalDevice> enumeratePhysicalDevices(Instance instance){ VEC_FUNC(PhysicalDevice, uint32_t, vkEnumeratePhysicalDevices, (VkInstance)(instance), &count, (VkPhysicalDevice*)(ret.data()));  }
inline void getPhysicalDeviceFeatures(PhysicalDevice physicalDevice, PhysicalDeviceFeatures& pFeatures){ return VKPP_DISPATCH(vkGetPhysicalDeviceFeatures((VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceFeatures*)(&pFeatures))); }
inline FormatProperties getPhysicalDeviceFormatProperties(PhysicalDevice physicalDevice, Format format){ FormatProperties ret = {}; VKPP_DISPATCH(vkGetPhysicalDeviceFormatProperties((VkPhysicalDevice)(physicalDevice), static_cast<VkFormat>(format), (VkFormatProperties*)(&ret))); return ret; }
inline ImageFormatProperties getPhysicalDeviceImageFormatProperties(PhysicalDevice physicalDevice, Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags = {}){ ImageFormatProperties ret = {}; VKPP_CALL(vkGetPhysicalDeviceImageFormatProperties((VkPhysicalDevice)(physicalDevice), static_cast<VkFormat>(format), static_cast<VkImageType>(type), static_cast<VkImageTiling>(tiling), static_cast<VkImageUsageFlags>(usage), static_cast<VkImageCreateFlags>(flags), (VkImageFormatProperties*)(&ret))); return ret; }
inline PhysicalDeviceProperties getPhysicalDeviceProperties(PhysicalDevice physicalDevice){ PhysicalDeviceProperties ret = {}; VKPP_DISPATCH(vkGetPhysicalDeviceProperties((VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceProperties*)(&ret))); return ret; }
inline void getPhysicalDeviceQueueFamilyProperties(PhysicalDevice physicalDevice, uint32_t& pQueueFamilyPropertyCount, QueueFamilyProperties* pQueueFamilyProperties = {}){ return VKPP_DISPATCH(vkGetPhysicalDeviceQueueFamilyProperties((VkPhysicalDevice)(physicalDevice), (uint32_t*)(&pQueueFamilyPropertyCount), (VkQueueFamilyProperties*)(pQueueFamilyProperties))); }
inline std::vector<QueueFamilyProperties> getPhysicalDeviceQueueFamilyProperties(PhysicalDevice physicalDevice){ VEC_FUNC_VOID(QueueFamilyProperties, uint32_t, vkGetPhysicalDeviceQueueFamilyProperties, (VkPhysicalDevice)(physicalDevice), &count, (VkQueueFamilyProperties*)(ret.data()));  }
inline PhysicalDeviceMemoryProperties getPhysicalDeviceMemoryProperties(PhysicalDevice physicalDevice){ PhysicalDeviceMemoryProperties ret = {}; VKPP_DISPATCH(vkGetPhysicalDeviceMemoryProperties((VkPhysicalDevice)(physicalDevice), (VkPhysicalDeviceMemoryProperties*)(&ret))); return ret; }
inline PFN_vkVoidFunction getInstanceProcAddr(Instance instance, const char* pName){ return static_cast<PFN_vkVoidFunction>(VKPP_DISPATCH(vkGetInstanceProcAddr((VkInstance)(instance), (const char*)(pName)))); }
inline PFN_vkVoidFunction getDeviceProcAddr(Device device, const char* pName){ return static_cast<PFN_vkVoidFunction>(VKPP_DISPATCH(vkGetDeviceProcAddr((VkDevice)(device), (const char*)(pName)))); }
inline Device createDevice(PhysicalDevice physicalDevice, const DeviceCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ Device ret = {}; VKPP_CALL(vkCreateDevice((VkPhysicalDevice)(physicalDevice), (const VkDeviceCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkDevice*)(&ret))); return ret; }
inline void destroyDevice(Device device = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyDevice((VkDevice)(device), (const VkAllocationCallbacks*)(pAllocator))); }
inline Result enumerateInstanceExtensionProperties(const char* pLayerName, uint32_t& pPropertyCount, ExtensionProperties* pProperties = {}){ return static_cast<Result>(VKPP_CALL(vkEnumerateInstanceExtensionProperties((const char*)(pLayerName), (uint32_t*)(&pPropertyCount), (VkExtensionProperties*)(pProperties)))); }
inline std::vector<ExtensionProperties> enumerateInstanceExtensionProperties(const char* pLayerName){ VEC_FUNC(ExtensionProperties, uint32_t, vkEnumerateInstanceExtensionProperties, (const char*)(pLayerName), &count, (VkExtensionProperties*)(ret.data()));  }
inline Result enumerateDeviceExtensionProperties(PhysicalDevice physicalDevice, const char* pLayerName, uint32_t& pPropertyCount, ExtensionProperties* pProperties = {}){ return static_cast<Result>(VKPP_CALL(vkEnumerateDeviceExtensionProperties((VkPhysicalDevice)(physicalDevice), (const char*)(pLayerName), (uint32_t*)(&pPropertyCount), (VkExtensionProperties*)(pProperties)))); }
inline std::vector<ExtensionProperties> enumerateDeviceExtensionProperties(PhysicalDevice physicalDevice, const char* pLayerName){ VEC_FUNC(ExtensionProperties, uint32_t, vkEnumerateDeviceExtensionProperties, (VkPhysicalDevice)(physicalDevice), (const char*)(pLayerName), &count, (VkExtensionProperties*)(ret.data()));  }
inline Result enumerateInstanceLayerProperties(uint32_t& pPropertyCount, LayerProperties* pProperties = {}){ return static_cast<Result>(VKPP_CALL(vkEnumerateInstanceLayerProperties((uint32_t*)(&pPropertyCount), (VkLayerProperties*)(pProperties)))); }
inline std::vector<LayerProperties> enumerateInstanceLayerProperties(){ VEC_FUNC(LayerProperties, uint32_t, vkEnumerateInstanceLayerProperties, &count, (VkLayerProperties*)(ret.data()));  }
inline Result enumerateDeviceLayerProperties(PhysicalDevice physicalDevice, uint32_t& pPropertyCount, LayerProperties* pProperties = {}){ return static_cast<Result>(VKPP_CALL(vkEnumerateDeviceLayerProperties((VkPhysicalDevice)(physicalDevice), (uint32_t*)(&pPropertyCount), (VkLayerProperties*)(pProperties)))); }
inline std::vector<LayerProperties> enumerateDeviceLayerProperties(PhysicalDevice physicalDevice){ VEC_FUNC(LayerProperties, uint32_t, vkEnumerateDeviceLayerProperties, (VkPhysicalDevice)(physicalDevice), &count, (VkLayerProperties*)(ret.data()));  }
inline Queue getDeviceQueue(Device device, uint32_t queueFamilyIndex, uint32_t queueIndex){ Queue ret = {}; VKPP_DISPATCH(vkGetDeviceQueue((VkDevice)(device), queueFamilyIndex, queueIndex, (VkQueue*)(&ret))); return ret; }
inline Result queueSubmit(Queue queue, uint32_t submitCount, const SubmitInfo& pSubmits, Fence fence = {}){ return static_cast<Result>(VKPP_CALL(vkQueueSubmit((VkQueue)(queue), submitCount, (const VkSubmitInfo*)(&pSubmits), (VkFence)(fence)))); }
inline Result queueSubmit(Queue queue, Span<const SubmitInfo> pSubmits, Fence fence = {}){ return VKPP_CALL(vkQueueSubmit((VkQueue)(queue), pSubmits.size(), (const VkSubmitInfo*)(pSubmits.data()), (VkFence)(fence))); }
inline Result queueWaitIdle(Queue queue){ return static_cast<Result>(VKPP_CALL(vkQueueWaitIdle((VkQueue)(queue)))); }
inline Result deviceWaitIdle(Device device){ return static_cast<Result>(VKPP_CALL(vkDeviceWaitIdle((VkDevice)(device)))); }
inline DeviceMemory allocateMemory(Device device, const MemoryAllocateInfo& pAllocateInfo, const AllocationCallbacks* pAllocator = {}){ DeviceMemory ret = {}; VKPP_CALL(vkAllocateMemory((VkDevice)(device), (const VkMemoryAllocateInfo*)(&pAllocateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkDeviceMemory*)(&ret))); return ret; }
inline void freeMemory(Device device, DeviceMemory memory = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkFreeMemory((VkDevice)(device), (VkDeviceMemory)(memory), (const VkAllocationCallbacks*)(pAllocator))); }
inline void* mapMemory(Device device, DeviceMemory memory, DeviceSize offset, DeviceSize size, MemoryMapFlags flags = {}){ void* ret = {}; VKPP_CALL(vkMapMemory((VkDevice)(device), (VkDeviceMemory)(memory), offset, size, static_cast<VkMemoryMapFlags>(flags), (void**)(&ret))); return ret; }
inline void unmapMemory(Device device, DeviceMemory memory){ return VKPP_DISPATCH(vkUnmapMemory((VkDevice)(device), (VkDeviceMemory)(memory))); }
inline Result flushMappedMemoryRanges(Device device, uint32_t memoryRangeCount, const MappedMemoryRange& pMemoryRanges){ return static_cast<Result>(VKPP_CALL(vkFlushMappedMemoryRanges((VkDevice)(device), memoryRangeCount, (const VkMappedMemoryRange*)(&pMemoryRanges)))); }
inline Result flushMappedMemoryRanges(Device device, Span<const MappedMemoryRange> pMemoryRanges){ return VKPP_CALL(vkFlushMappedMemoryRanges((VkDevice)(device), pMemoryRanges.size(), (const VkMappedMemoryRange*)(pMemoryRanges.data()))); }
inline Result invalidateMappedMemoryRanges(Device device, uint32_t memoryRangeCount, const MappedMemoryRange& pMemoryRanges){ return static_cast<Result>(VKPP_CALL(vkInvalidateMappedMemoryRanges((VkDevice)(device), memoryRangeCount, (const VkMappedMemoryRange*)(&pMemoryRanges)))); }
inline Result invalidateMappedMemoryRanges(Device device, Span<const MappedMemoryRange> pMemoryRanges){ return VKPP_CALL(vkInvalidateMappedMemoryRanges((VkDevice)(device), pMemoryRanges.size(), (const VkMappedMemoryRange*)(pMemoryRanges.data()))); }
inline DeviceSize getDeviceMemoryCommitment(Device device, DeviceMemory memory){ DeviceSize ret = {}; VKPP_DISPATCH(vkGetDeviceMemoryCommitment((VkDevice)(device), (VkDeviceMemory)(memory), (VkDeviceSize*)(&ret))); return ret; }
inline Result bindBufferMemory(Device device, Buffer buffer, DeviceMemory memory, DeviceSize memoryOffset){ return static_cast<Result>(VKPP_CALL(vkBindBufferMemory((VkDevice)(device), (VkBuffer)(buffer), (VkDeviceMemory)(memory), memoryOffset))); }
inline Result bindImageMemory(Device device, Image image, DeviceMemory memory, DeviceSize memoryOffset){ return static_cast<Result>(VKPP_CALL(vkBindImageMemory((VkDevice)(device), (VkImage)(image), (VkDeviceMemory)(memory), memoryOffset))); }
inline MemoryRequirements getBufferMemoryRequirements(Device device, Buffer buffer){ MemoryRequirements ret = {}; VKPP_DISPATCH(vkGetBufferMemoryRequirements((VkDevice)(device), (VkBuffer)(buffer), (VkMemoryRequirements*)(&ret))); return ret; }
inline MemoryRequirements getImageMemoryRequirements(Device device, Image image){ MemoryRequirements ret = {}; VKPP_DISPATCH(vkGetImageMemoryRequirements((VkDevice)(device), (VkImage)(image), (VkMemoryRequirements*)(&ret))); return ret; }
inline void getImageSparseMemoryRequirements(Device device, Image image, uint32_t& pSparseMemoryRequirementCount, SparseImageMemoryRequirements* pSparseMemoryRequirements = {}){ return VKPP_DISPATCH(vkGetImageSparseMemoryRequirements((VkDevice)(device), (VkImage)(image), (uint32_t*)(&pSparseMemoryRequirementCount), (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements))); }
inline std::vector<SparseImageMemoryRequirements> getImageSparseMemoryRequirements(Device device, Image image){ VEC_FUNC_VOID(SparseImageMemoryRequirements, uint32_t, vkGetImageSparseMemoryRequirements, (VkDevice)(device), (VkImage)(image), &count, (VkSparseImageMemoryRequirements*)(ret.data()));  }
inline void getPhysicalDeviceSparseImageFormatProperties(PhysicalDevice physicalDevice, Format format, ImageType type, SampleCountBits samples, ImageUsageFlags usage, ImageTiling tiling, uint32_t& pPropertyCount, SparseImageFormatProperties* pProperties = {}){ return VKPP_DISPATCH(vkGetPhysicalDeviceSparseImageFormatProperties((VkPhysicalDevice)(physicalDevice), static_cast<VkFormat>(format), static_cast<VkImageType>(type), static_cast<VkSampleCountFlagBits>(samples), static_cast<VkImageUsageFlags>(usage), static_cast<VkImageTiling>(tiling), (uint32_t*)(&pPropertyCount), (VkSparseImageFormatProperties*)(pProperties))); }
inline std::vector<SparseImageFormatProperties> getPhysicalDeviceSparseImageFormatProperties(PhysicalDevice physicalDevice, Format format, ImageType type, SampleCountBits samples, ImageUsageFlags usage, ImageTiling tiling){ VEC_FUNC_VOID(SparseImageFormatProperties, uint32_t, vkGetPhysicalDeviceSparseImageFormatProperties, (VkPhysicalDevice)(physicalDevice), static_cast<VkFormat>(format), static_cast<VkImageType>(type), static_cast<VkSampleCountFlagBits>(samples), static_cast<VkImageUsageFlags>(usage), static_cast<VkImageTiling>(tiling), &count, (VkSparseImageFormatProperties*)(ret.data()));  }
inline Result queueBindSparse(Queue queue, uint32_t bindInfoCount, const BindSparseInfo& pBindInfo, Fence fence = {}){ return static_cast<Result>(VKPP_CALL(vkQueueBindSparse((VkQueue)(queue), bindInfoCount, (const VkBindSparseInfo*)(&pBindInfo), (VkFence)(fence)))); }
inline Result queueBindSparse(Queue queue, Span<const BindSparseInfo> pBindInfo, Fence fence = {}){ return VKPP_CALL(vkQueueBindSparse((VkQueue)(queue), pBindInfo.size(), (const VkBindSparseInfo*)(pBindInfo.data()), (VkFence)(fence))); }
inline Fence createFence(Device device, const FenceCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ Fence ret = {}; VKPP_CALL(vkCreateFence((VkDevice)(device), (const VkFenceCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkFence*)(&ret))); return ret; }
inline void destroyFence(Device device, Fence fence = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyFence((VkDevice)(device), (VkFence)(fence), (const VkAllocationCallbacks*)(pAllocator))); }
inline Result resetFences(Device device, uint32_t fenceCount, const Fence& pFences){ return static_cast<Result>(VKPP_CALL(vkResetFences((VkDevice)(device), fenceCount, (const VkFence*)(&pFences)))); }
inline Result resetFences(Device device, Span<const Fence> pFences){ return VKPP_CALL(vkResetFences((VkDevice)(device), pFences.size(), (const VkFence*)(pFences.data()))); }
inline Result getFenceStatus(Device device, Fence fence){ return static_cast<Result>(VKPP_CALL(vkGetFenceStatus((VkDevice)(device), (VkFence)(fence)))); }
inline Result waitForFences(Device device, uint32_t fenceCount, const Fence& pFences, Bool32 waitAll, uint64_t timeout){ return static_cast<Result>(VKPP_CALL(vkWaitForFences((VkDevice)(device), fenceCount, (const VkFence*)(&pFences), waitAll, timeout))); }
inline Result waitForFences(Device device, Span<const Fence> pFences, Bool32 waitAll, uint64_t timeout){ return VKPP_CALL(vkWaitForFences((VkDevice)(device), pFences.size(), (const VkFence*)(pFences.data()), waitAll, timeout)); }
inline Semaphore createSemaphore(Device device, const SemaphoreCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ Semaphore ret = {}; VKPP_CALL(vkCreateSemaphore((VkDevice)(device), (const VkSemaphoreCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSemaphore*)(&ret))); return ret; }
inline void destroySemaphore(Device device, Semaphore semaphore = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroySemaphore((VkDevice)(device), (VkSemaphore)(semaphore), (const VkAllocationCallbacks*)(pAllocator))); }
inline Event createEvent(Device device, const EventCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ Event ret = {}; VKPP_CALL(vkCreateEvent((VkDevice)(device), (const VkEventCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkEvent*)(&ret))); return ret; }
inline void destroyEvent(Device device, Event event = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyEvent((VkDevice)(device), (VkEvent)(event), (const VkAllocationCallbacks*)(pAllocator))); }
inline Result getEventStatus(Device device, Event event){ return static_cast<Result>(VKPP_CALL(vkGetEventStatus((VkDevice)(device), (VkEvent)(event)))); }
inline Result setEvent(Device device, Event event){ return static_cast<Result>(VKPP_CALL(vkSetEvent((VkDevice)(device), (VkEvent)(event)))); }
inline Result resetEvent(Device device, Event event){ return static_cast<Result>(VKPP_CALL(vkResetEvent((VkDevice)(device), (VkEvent)(event)))); }
inline QueryPool createQueryPool(Device device, const QueryPoolCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ QueryPool ret = {}; VKPP_CALL(vkCreateQueryPool((VkDevice)(device), (const VkQueryPoolCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkQueryPool*)(&ret))); return ret; }
inline void destroyQueryPool(Device device, QueryPool queryPool = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyQueryPool((VkDevice)(device), (VkQueryPool)(queryPool), (const VkAllocationCallbacks*)(pAllocator))); }
inline Result getQueryPoolResults(Device device, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, DeviceSize stride, QueryResultFlags flags = {}){ return static_cast<Result>(VKPP_CALL(vkGetQueryPoolResults((VkDevice)(device), (VkQueryPool)(queryPool), firstQuery, queryCount, dataSize, (void*)(pData), stride, static_cast<VkQueryResultFlags>(flags)))); }
inline std::vector<uint8_t> getQueryPoolResults(Device device, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, DeviceSize stride, QueryResultFlags flags = {}){ VEC_FUNC_RET(uint8_t, dataSize, vkGetQueryPoolResults, (VkDevice)(device), (VkQueryPool)(queryPool), firstQuery, queryCount, dataSize, (void*)(ret.data()), stride, static_cast<VkQueryResultFlags>(flags));  }
inline Buffer createBuffer(Device device, const BufferCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ Buffer ret = {}; VKPP_CALL(vkCreateBuffer((VkDevice)(device), (const VkBufferCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkBuffer*)(&ret))); return ret; }
inline void destroyBuffer(Device device, Buffer buffer = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyBuffer((VkDevice)(device), (VkBuffer)(buffer), (const VkAllocationCallbacks*)(pAllocator))); }
inline BufferView createBufferView(Device device, const BufferViewCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ BufferView ret = {}; VKPP_CALL(vkCreateBufferView((VkDevice)(device), (const VkBufferViewCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkBufferView*)(&ret))); return ret; }
inline void destroyBufferView(Device device, BufferView bufferView = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyBufferView((VkDevice)(device), (VkBufferView)(bufferView), (const VkAllocationCallbacks*)(pAllocator))); }
inline Image createImage(Device device, const ImageCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ Image ret = {}; VKPP_CALL(vkCreateImage((VkDevice)(device), (const VkImageCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkImage*)(&ret))); return ret; }
inline void destroyImage(Device device, Image image = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyImage((VkDevice)(device), (VkImage)(image), (const VkAllocationCallbacks*)(pAllocator))); }
inline SubresourceLayout getImageSubresourceLayout(Device device, Image image, const ImageSubresource& pSubresource){ SubresourceLayout ret = {}; VKPP_DISPATCH(vkGetImageSubresourceLayout((VkDevice)(device), (VkImage)(image), (const VkImageSubresource*)(&pSubresource), (VkSubresourceLayout*)(&ret))); return ret; }
inline ImageView createImageView(Device device, const ImageViewCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ ImageView ret = {}; VKPP_CALL(vkCreateImageView((VkDevice)(device), (const VkImageViewCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkImageView*)(&ret))); return ret; }
inline void destroyImageView(Device device, ImageView imageView = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyImageView((VkDevice)(device), (VkImageView)(imageView), (const VkAllocationCallbacks*)(pAllocator))); }
inline ShaderModule createShaderModule(Device device, const ShaderModuleCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ ShaderModule ret = {}; VKPP_CALL(vkCreateShaderModule((VkDevice)(device), (const VkShaderModuleCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkShaderModule*)(&ret))); return ret; }
inline void destroyShaderModule(Device device, ShaderModule shaderModule = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyShaderModule((VkDevice)(device), (VkShaderModule)(shaderModule), (const VkAllocationCallbacks*)(pAllocator))); }
inline PipelineCache createPipelineCache(Device device, const PipelineCacheCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ PipelineCache ret = {}; VKPP_CALL(vkCreatePipelineCache((VkDevice)(device), (const VkPipelineCacheCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkPipelineCache*)(&ret))); return ret; }
inline void destroyPipelineCache(Device device, PipelineCache pipelineCache = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyPipelineCache((VkDevice)(device), (VkPipelineCache)(pipelineCache), (const VkAllocationCallbacks*)(pAllocator))); }
inline Result getPipelineCacheData(Device device, PipelineCache pipelineCache, size_t& pDataSize, void* pData = {}){ return static_cast<Result>(VKPP_CALL(vkGetPipelineCacheData((VkDevice)(device), (VkPipelineCache)(pipelineCache), (size_t*)(&pDataSize), (void*)(pData)))); }
inline std::vector<uint8_t> getPipelineCacheData(Device device, PipelineCache pipelineCache){ VEC_FUNC(uint8_t, size_t, vkGetPipelineCacheData, (VkDevice)(device), (VkPipelineCache)(pipelineCache), &count, (void*)(ret.data()));  }
inline Result mergePipelineCaches(Device device, PipelineCache dstCache, uint32_t srcCacheCount, const PipelineCache& pSrcCaches){ return static_cast<Result>(VKPP_CALL(vkMergePipelineCaches((VkDevice)(device), (VkPipelineCache)(dstCache), srcCacheCount, (const VkPipelineCache*)(&pSrcCaches)))); }
inline Result mergePipelineCaches(Device device, PipelineCache dstCache, Span<const PipelineCache> pSrcCaches){ return VKPP_CALL(vkMergePipelineCaches((VkDevice)(device), (VkPipelineCache)(dstCache), pSrcCaches.size(), (const VkPipelineCache*)(pSrcCaches.data()))); }
inline Result createGraphicsPipelines(Device device, PipelineCache pipelineCache, uint32_t createInfoCount, const GraphicsPipelineCreateInfo& pCreateInfos, const AllocationCallbacks* pAllocator, Pipeline& pPipelines){ return static_cast<Result>(VKPP_CALL(vkCreateGraphicsPipelines((VkDevice)(device), (VkPipelineCache)(pipelineCache), createInfoCount, (const VkGraphicsPipelineCreateInfo*)(&pCreateInfos), (const VkAllocationCallbacks*)(pAllocator), (VkPipeline*)(&pPipelines)))); }
inline std::vector<Pipeline> createGraphicsPipelines(Device device, PipelineCache pipelineCache, Span<const GraphicsPipelineCreateInfo> pCreateInfos, const AllocationCallbacks* pAllocator = {}){ VEC_FUNC_RET(Pipeline, pCreateInfos.size(), vkCreateGraphicsPipelines, (VkDevice)(device), (VkPipelineCache)(pipelineCache), pCreateInfos.size(), (const VkGraphicsPipelineCreateInfo*)(pCreateInfos.data()), (const VkAllocationCallbacks*)(pAllocator), (VkPipeline*)(ret.data()));  }
inline Result createComputePipelines(Device device, PipelineCache pipelineCache, uint32_t createInfoCount, const ComputePipelineCreateInfo& pCreateInfos, const AllocationCallbacks* pAllocator, Pipeline& pPipelines){ return static_cast<Result>(VKPP_CALL(vkCreateComputePipelines((VkDevice)(device), (VkPipelineCache)(pipelineCache), createInfoCount, (const VkComputePipelineCreateInfo*)(&pCreateInfos), (const VkAllocationCallbacks*)(pAllocator), (VkPipeline*)(&pPipelines)))); }
inline std::vector<Pipeline> createComputePipelines(Device device, PipelineCache pipelineCache, Span<const ComputePipelineCreateInfo> pCreateInfos, const AllocationCallbacks* pAllocator = {}){ VEC_FUNC_RET(Pipeline, pCreateInfos.size(), vkCreateComputePipelines, (VkDevice)(device), (VkPipelineCache)(pipelineCache), pCreateInfos.size(), (const VkComputePipelineCreateInfo*)(pCreateInfos.data()), (const VkAllocationCallbacks*)(pAllocator), (VkPipeline*)(ret.data()));  }
inline void destroyPipeline(Device device, Pipeline pipeline = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyPipeline((VkDevice)(device), (VkPipeline)(pipeline), (const VkAllocationCallbacks*)(pAllocator))); }
inline PipelineLayout createPipelineLayout(Device device, const PipelineLayoutCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ PipelineLayout ret = {}; VKPP_CALL(vkCreatePipelineLayout((VkDevice)(device), (const VkPipelineLayoutCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkPipelineLayout*)(&ret))); return ret; }
inline void destroyPipelineLayout(Device device, PipelineLayout pipelineLayout = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyPipelineLayout((VkDevice)(device), (VkPipelineLayout)(pipelineLayout), (const VkAllocationCallbacks*)(pAllocator))); }
inline Sampler createSampler(Device device, const SamplerCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ Sampler ret = {}; VKPP_CALL(vkCreateSampler((VkDevice)(device), (const VkSamplerCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkSampler*)(&ret))); return ret; }
inline void destroySampler(Device device, Sampler sampler = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroySampler((VkDevice)(device), (VkSampler)(sampler), (const VkAllocationCallbacks*)(pAllocator))); }
inline DescriptorSetLayout createDescriptorSetLayout(Device device, const DescriptorSetLayoutCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ DescriptorSetLayout ret = {}; VKPP_CALL(vkCreateDescriptorSetLayout((VkDevice)(device), (const VkDescriptorSetLayoutCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkDescriptorSetLayout*)(&ret))); return ret; }
inline void destroyDescriptorSetLayout(Device device, DescriptorSetLayout descriptorSetLayout = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyDescriptorSetLayout((VkDevice)(device), (VkDescriptorSetLayout)(descriptorSetLayout), (const VkAllocationCallbacks*)(pAllocator))); }
inline DescriptorPool createDescriptorPool(Device device, const DescriptorPoolCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ DescriptorPool ret = {}; VKPP_CALL(vkCreateDescriptorPool((VkDevice)(device), (const VkDescriptorPoolCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkDescriptorPool*)(&ret))); return ret; }
inline void destroyDescriptorPool(Device device, DescriptorPool descriptorPool = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyDescriptorPool((VkDevice)(device), (VkDescriptorPool)(descriptorPool), (const VkAllocationCallbacks*)(pAllocator))); }
inline Result resetDescriptorPool(Device device, DescriptorPool descriptorPool, DescriptorPoolResetFlags flags = {}){ return static_cast<Result>(VKPP_CALL(vkResetDescriptorPool((VkDevice)(device), (VkDescriptorPool)(descriptorPool), static_cast<VkDescriptorPoolResetFlags>(flags)))); }
inline Result allocateDescriptorSets(Device device, const DescriptorSetAllocateInfo& pAllocateInfo, DescriptorSet& pDescriptorSets){ return static_cast<Result>(VKPP_CALL(vkAllocateDescriptorSets((VkDevice)(device), (const VkDescriptorSetAllocateInfo*)(&pAllocateInfo), (VkDescriptorSet*)(&pDescriptorSets)))); }
inline std::vector<DescriptorSet> allocateDescriptorSets(Device device, const DescriptorSetAllocateInfo& pAllocateInfo){ VEC_FUNC_RET(DescriptorSet, pAllocateInfo.descriptorSetCount, vkAllocateDescriptorSets, (VkDevice)(device), (const VkDescriptorSetAllocateInfo*)(&pAllocateInfo), (VkDescriptorSet*)(ret.data()));  }
inline Result freeDescriptorSets(Device device, DescriptorPool descriptorPool, uint32_t descriptorSetCount, const DescriptorSet& pDescriptorSets){ return static_cast<Result>(VKPP_CALL(vkFreeDescriptorSets((VkDevice)(device), (VkDescriptorPool)(descriptorPool), descriptorSetCount, (const VkDescriptorSet*)(&pDescriptorSets)))); }
inline Result freeDescriptorSets(Device device, DescriptorPool descriptorPool, Span<const DescriptorSet> pDescriptorSets){ return VKPP_CALL(vkFreeDescriptorSets((VkDevice)(device), (VkDescriptorPool)(descriptorPool), pDescriptorSets.size(), (const VkDescriptorSet*)(pDescriptorSets.data()))); }
inline void updateDescriptorSets(Device device, uint32_t descriptorWriteCount, const WriteDescriptorSet& pDescriptorWrites, uint32_t descriptorCopyCount, const CopyDescriptorSet& pDescriptorCopies){ return VKPP_DISPATCH(vkUpdateDescriptorSets((VkDevice)(device), descriptorWriteCount, (const VkWriteDescriptorSet*)(&pDescriptorWrites), descriptorCopyCount, (const VkCopyDescriptorSet*)(&pDescriptorCopies))); }
inline void updateDescriptorSets(Device device, Span<const WriteDescriptorSet> pDescriptorWrites, Span<const CopyDescriptorSet> pDescriptorCopies){ VKPP_DISPATCH(vkUpdateDescriptorSets((VkDevice)(device), pDescriptorWrites.size(), (const VkWriteDescriptorSet*)(pDescriptorWrites.data()), pDescriptorCopies.size(), (const VkCopyDescriptorSet*)(pDescriptorCopies.data()))); }
inline Framebuffer createFramebuffer(Device device, const FramebufferCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ Framebuffer ret = {}; VKPP_CALL(vkCreateFramebuffer((VkDevice)(device), (const VkFramebufferCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkFramebuffer*)(&ret))); return ret; }
inline void destroyFramebuffer(Device device, Framebuffer framebuffer = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyFramebuffer((VkDevice)(device), (VkFramebuffer)(framebuffer), (const VkAllocationCallbacks*)(pAllocator))); }
inline RenderPass createRenderPass(Device device, const RenderPassCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ RenderPass ret = {}; VKPP_CALL(vkCreateRenderPass((VkDevice)(device), (const VkRenderPassCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkRenderPass*)(&ret))); return ret; }
inline void destroyRenderPass(Device device, RenderPass renderPass = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyRenderPass((VkDevice)(device), (VkRenderPass)(renderPass), (const VkAllocationCallbacks*)(pAllocator))); }
inline void getRenderAreaGranularity(Device device, RenderPass renderPass, Extent2D& pGranularity){ return VKPP_DISPATCH(vkGetRenderAreaGranularity((VkDevice)(device), (VkRenderPass)(renderPass), (VkExtent2D*)(&pGranularity))); }
inline CommandPool createCommandPool(Device device, const CommandPoolCreateInfo& pCreateInfo, const AllocationCallbacks* pAllocator = {}){ CommandPool ret = {}; VKPP_CALL(vkCreateCommandPool((VkDevice)(device), (const VkCommandPoolCreateInfo*)(&pCreateInfo), (const VkAllocationCallbacks*)(pAllocator), (VkCommandPool*)(&ret))); return ret; }
inline void destroyCommandPool(Device device, CommandPool commandPool = {}, const AllocationCallbacks* pAllocator = {}){ return VKPP_DISPATCH(vkDestroyCommandPool((VkDevice)(device), (VkCommandPool)(commandPool), (const VkAllocationCallbacks*)(pAllocator))); }
inline Result resetCommandPool(Device device, CommandPool commandPool, CommandPoolResetFlags flags = {}){ return static_cast<Result>(VKPP_CALL(vkResetCommandPool((VkDevice)(device), (VkCommandPool)(commandPool), static_cast<VkCommandPoolResetFlags>(flags)))); }
inline Result allocateCommandBuffers(Device device, const CommandBufferAllocateInfo& pAllocateInfo, CommandBuffer& pCommandBuffers){ return static_cast<Result>(VKPP_CALL(vkAllocateCommandBuffers((VkDevice)(device), (const VkCommandBufferAllocateInfo*)(&pAllocateInfo), (VkCommandBuffer*)(&pCommandBuffers)))); }
inline std::vector<CommandBuffer> allocateCommandBuffers(Device device, const CommandBufferAllocateInfo& pAllocateInfo){ VEC_FUNC_RET(CommandBuffer, pAllocateInfo.commandBufferCount, vkAllocateCommandBuffers, (VkDevice)(device), (const VkCommandBufferAllocateInfo*)(&pAllocateInfo), (VkCommandBuffer*)(ret.data()));  }
inline void freeCommandBuffers(Device device, CommandPool commandPool, uint32_t commandBufferCount, const CommandBuffer& pCommandBuffers){ return VKPP_DISPATCH(vkFreeCommandBuffers((VkDevice)(device), (VkCommandPool)(commandPool), commandBufferCount, (const VkCommandBuffer*)(&pCommandBuffers))); }
inline void freeCommandBuffers(Device device, CommandPool commandPool, Span<const CommandBuffer> pCommandBuffers){ VKPP_DISPATCH(vkFreeCommandBuffers((VkDevice)(device), (VkCommandPool)(commandPool), pCommandBuffers.size(), (const VkCommandBuffer*)(pCommandBuffers.data()))); }
inline Result beginCommandBuffer(CommandBuffer commandBuffer, const CommandBufferBeginInfo& pBeginInfo){ return static_cast<Result>(VKPP_CALL(vkBeginCommandBuffer((VkCommandBuffer)(commandBuffer), (const VkCommandBufferBeginInfo*)(&pBeginInfo)))); }
inline Result endCommandBuffer(CommandBuffer commandBuffer){ return static_cast<Result>(VKPP_CALL(vkEndCommandBuffer((VkCommandBuffer)(commandBuffer)))); }
inline Result resetCommandBuffer(CommandBuffer commandBuffer, CommandBufferResetFlags flags = {}){ return static_cast<Result>(VKPP_CALL(vkResetCommandBuffer((VkCommandBuffer)(commandBuffer), static_cast<VkCommandBufferResetFlags>(flags)))); }
inline void cmdBindPipeline(CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, Pipeline pipeline){ return VKPP_DISPATCH(vkCmdBindPipeline((VkCommandBuffer)(commandBuffer), static_cast<VkPipelineBindPoint>(pipelineBindPoint), (VkPipeline)(pipeline))); }
inline void cmdSetViewport(CommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const Viewport& pViewports){ return VKPP_DISPATCH(vkCmdSetViewport((VkCommandBuffer)(commandBuffer), firstViewport, viewportCount, (const VkViewport*)(&pViewports))); }
inline void cmdSetViewport(CommandBuffer commandBuffer, uint32_t firstViewport, Span<const Viewport> pViewports){ VKPP_DISPATCH(vkCmdSetViewport((VkCommandBuffer)(commandBuffer), firstViewport, pViewports.size(), (const VkViewport*)(pViewports.data()))); }
inline void cmdSetScissor(CommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const Rect2D& pScissors){ return VKPP_DISPATCH(vkCmdSetScissor((VkCommandBuffer)(commandBuffer), firstScissor, scissorCount, (const VkRect2D*)(&pScissors))); }
inline void cmdSetScissor(CommandBuffer commandBuffer, uint32_t firstScissor, Span<const Rect2D> pScissors){ VKPP_DISPATCH(vkCmdSetScissor((VkCommandBuffer)(commandBuffer), firstScissor, pScissors.size(), (const VkRect2D*)(pScissors.data()))); }
inline void cmdSetLineWidth(CommandBuffer commandBuffer, float lineWidth){ return VKPP_DISPATCH(vkCmdSetLineWidth((VkCommandBuffer)(commandBuffer), lineWidth)); }
inline void cmdSetDepthBias(CommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor){ return VKPP_DISPATCH(vkCmdSetDepthBias((VkCommandBuffer)(commandBuffer), depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)); }
inline void cmdSetBlendConstants(CommandBuffer commandBuffer, std::array<const float, 4> blendConstants){ return VKPP_DISPATCH(vkCmdSetBlendConstants((VkCommandBuffer)(commandBuffer), blendConstants.data())); }
inline void cmdSetDepthBounds(CommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds){ return VKPP_DISPATCH(vkCmdSetDepthBounds((VkCommandBuffer)(commandBuffer), minDepthBounds, maxDepthBounds)); }
inline void cmdSetStencilCompareMask(CommandBuffer commandBuffer, StencilFaceFlags faceMask, uint32_t compareMask){ return VKPP_DISPATCH(vkCmdSetStencilCompareMask((VkCommandBuffer)(commandBuffer), static_cast<VkStencilFaceFlags>(faceMask), compareMask)); }
inline void cmdSetStencilWriteMask(CommandBuffer commandBuffer, StencilFaceFlags faceMask, uint32_t writeMask){ return VKPP_DISPATCH(vkCmdSetStencilWriteMask((VkCommandBuffer)(commandBuffer), static_cast<VkStencilFaceFlags>(faceMask), writeMask)); }
inline void cmdSetStencilReference(CommandBuffer commandBuffer, StencilFaceFlags faceMask, uint32_t reference){ return VKPP_DISPATCH(vkCmdSetStencilReference((VkCommandBuffer)(commandBuffer), static_cast<VkStencilFaceFlags>(faceMask), reference)); }
inline void cmdBindDescriptorSets(CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const DescriptorSet& pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t& pDynamicOffsets){ return VKPP_DISPATCH(vkCmdBindDescriptorSets((VkCommandBuffer)(commandBuffer), static_cast<VkPipelineBindPoint>(pipelineBindPoint), (VkPipelineLayout)(layout), firstSet, descriptorSetCount, (const VkDescriptorSet*)(&pDescriptorSets), dynamicOffsetCount, (const uint32_t*)(&pDynamicOffsets))); }
inline void cmdBindDescriptorSets(CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t firstSet, Span<const DescriptorSet> pDescriptorSets, Span<const uint32_t> pDynamicOffsets){ VKPP_DISPATCH(vkCmdBindDescriptorSets((VkCommandBuffer)(commandBuffer), static_cast<VkPipelineBindPoint>(pipelineBindPoint), (VkPipelineLayout)(layout), firstSet, pDescriptorSets.size(), (const VkDescriptorSet*)(pDescriptorSets.data()), pDynamicOffsets.size(), (const uint32_t*)(pDynamicOffsets.data()))); }
inline void cmdBindIndexBuffer(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, IndexType indexType){ return VKPP_DISPATCH(vkCmdBindIndexBuffer((VkCommandBuffer)(commandBuffer), (VkBuffer)(buffer), offset, static_cast<VkIndexType>(indexType))); }
inline void cmdBindVertexBuffers(CommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const Buffer& pBuffers, const DeviceSize& pOffsets){ return VKPP_DISPATCH(vkCmdBindVertexBuffers((VkCommandBuffer)(commandBuffer), firstBinding, bindingCount, (const VkBuffer*)(&pBuffers), (const VkDeviceSize*)(&pOffsets))); }
inline void cmdBindVertexBuffers(CommandBuffer commandBuffer, uint32_t firstBinding, Span<const Buffer> pBuffers, Span<const DeviceSize> pOffsets){ VKPP_DISPATCH(vkCmdBindVertexBuffers((VkCommandBuffer)(commandBuffer), firstBinding, pBuffers.size(), (const VkBuffer*)(pBuffers.data()), (const VkDeviceSize*)(pOffsets.data()))); }
inline void cmdDraw(CommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance){ return VKPP_DISPATCH(vkCmdDraw((VkCommandBuffer)(commandBuffer), vertexCount, instanceCount, firstVertex, firstInstance)); }
inline void cmdDrawIndexed(CommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance){ return VKPP_DISPATCH(vkCmdDrawIndexed((VkCommandBuffer)(commandBuffer), indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)); }
inline void cmdDrawIndirect(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride){ return VKPP_DISPATCH(vkCmdDrawIndirect((VkCommandBuffer)(commandBuffer), (VkBuffer)(buffer), offset, drawCount, stride)); }
inline void cmdDrawIndexedIndirect(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride){ return VKPP_DISPATCH(vkCmdDrawIndexedIndirect((VkCommandBuffer)(commandBuffer), (VkBuffer)(buffer), offset, drawCount, stride)); }
inline void cmdDispatch(CommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ){ return VKPP_DISPATCH(vkCmdDispatch((VkCommandBuffer)(commandBuffer), groupCountX, groupCountY, groupCountZ)); }
inline void cmdDispatchIndirect(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset){ return VKPP_DISPATCH(vkCmdDispatchIndirect((VkCommandBuffer)(commandBuffer), (VkBuffer)(buffer), offset)); }
inline void cmdCopyBuffer(CommandBuffer commandBuffer, Buffer srcBuffer, Buffer dstBuffer, uint32_t regionCount, const BufferCopy& pRegions){ return VKPP_DISPATCH(vkCmdCopyBuffer((VkCommandBuffer)(commandBuffer), (VkBuffer)(srcBuffer), (VkBuffer)(dstBuffer), regionCount, (const VkBufferCopy*)(&pRegions))); }
inline void cmdCopyBuffer(CommandBuffer commandBuffer, Buffer srcBuffer, Buffer dstBuffer, Span<const BufferCopy> pRegions){ VKPP_DISPATCH(vkCmdCopyBuffer((VkCommandBuffer)(commandBuffer), (VkBuffer)(srcBuffer), (VkBuffer)(dstBuffer), pRegions.size(), (const VkBufferCopy*)(pRegions.data()))); }
inline void cmdCopyImage(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageCopy& pRegions){ return VKPP_DISPATCH(vkCmdCopyImage((VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), regionCount, (const VkImageCopy*)(&pRegions))); }
inline void cmdCopyImage(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, Span<const ImageCopy> pRegions){ VKPP_DISPATCH(vkCmdCopyImage((VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), pRegions.size(), (const VkImageCopy*)(pRegions.data()))); }
inline void cmdBlitImage(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageBlit& pRegions, Filter filter){ return VKPP_DISPATCH(vkCmdBlitImage((VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), regionCount, (const VkImageBlit*)(&pRegions), static_cast<VkFilter>(filter))); }
inline void cmdBlitImage(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, Span<const ImageBlit> pRegions, Filter filter){ VKPP_DISPATCH(vkCmdBlitImage((VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), pRegions.size(), (const VkImageBlit*)(pRegions.data()), static_cast<VkFilter>(filter))); }
inline void cmdCopyBufferToImage(CommandBuffer commandBuffer, Buffer srcBuffer, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const BufferImageCopy& pRegions){ return VKPP_DISPATCH(vkCmdCopyBufferToImage((VkCommandBuffer)(commandBuffer), (VkBuffer)(srcBuffer), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), regionCount, (const VkBufferImageCopy*)(&pRegions))); }
inline void cmdCopyBufferToImage(CommandBuffer commandBuffer, Buffer srcBuffer, Image dstImage, ImageLayout dstImageLayout, Span<const BufferImageCopy> pRegions){ VKPP_DISPATCH(vkCmdCopyBufferToImage((VkCommandBuffer)(commandBuffer), (VkBuffer)(srcBuffer), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), pRegions.size(), (const VkBufferImageCopy*)(pRegions.data()))); }
inline void cmdCopyImageToBuffer(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Buffer dstBuffer, uint32_t regionCount, const BufferImageCopy& pRegions){ return VKPP_DISPATCH(vkCmdCopyImageToBuffer((VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkBuffer)(dstBuffer), regionCount, (const VkBufferImageCopy*)(&pRegions))); }
inline void cmdCopyImageToBuffer(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Buffer dstBuffer, Span<const BufferImageCopy> pRegions){ VKPP_DISPATCH(vkCmdCopyImageToBuffer((VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkBuffer)(dstBuffer), pRegions.size(), (const VkBufferImageCopy*)(pRegions.data()))); }
inline void cmdUpdateBuffer(CommandBuffer commandBuffer, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize dataSize, const void* pData){ return VKPP_DISPATCH(vkCmdUpdateBuffer((VkCommandBuffer)(commandBuffer), (VkBuffer)(dstBuffer), dstOffset, dataSize, (const void*)(pData))); }
inline void cmdUpdateBuffer(CommandBuffer commandBuffer, Buffer dstBuffer, DeviceSize dstOffset, Span<const uint8_t> pData){ VKPP_DISPATCH(vkCmdUpdateBuffer((VkCommandBuffer)(commandBuffer), (VkBuffer)(dstBuffer), dstOffset, pData.size(), (const void*)(pData.data()))); }
inline void cmdFillBuffer(CommandBuffer commandBuffer, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize size, uint32_t data){ return VKPP_DISPATCH(vkCmdFillBuffer((VkCommandBuffer)(commandBuffer), (VkBuffer)(dstBuffer), dstOffset, size, data)); }
inline void cmdClearColorImage(CommandBuffer commandBuffer, Image image, ImageLayout imageLayout, const ClearColorValue& pColor, uint32_t rangeCount, const ImageSubresourceRange& pRanges){ return VKPP_DISPATCH(vkCmdClearColorImage((VkCommandBuffer)(commandBuffer), (VkImage)(image), static_cast<VkImageLayout>(imageLayout), (const VkClearColorValue*)(&pColor), rangeCount, (const VkImageSubresourceRange*)(&pRanges))); }
inline void cmdClearColorImage(CommandBuffer commandBuffer, Image image, ImageLayout imageLayout, const ClearColorValue& pColor, Span<const ImageSubresourceRange> pRanges){ VKPP_DISPATCH(vkCmdClearColorImage((VkCommandBuffer)(commandBuffer), (VkImage)(image), static_cast<VkImageLayout>(imageLayout), (const VkClearColorValue*)(&pColor), pRanges.size(), (const VkImageSubresourceRange*)(pRanges.data()))); }
inline void cmdClearDepthStencilImage(CommandBuffer commandBuffer, Image image, ImageLayout imageLayout, const ClearDepthStencilValue& pDepthStencil, uint32_t rangeCount, const ImageSubresourceRange& pRanges){ return VKPP_DISPATCH(vkCmdClearDepthStencilImage((VkCommandBuffer)(commandBuffer), (VkImage)(image), static_cast<VkImageLayout>(imageLayout), (const VkClearDepthStencilValue*)(&pDepthStencil), rangeCount, (const VkImageSubresourceRange*)(&pRanges))); }
inline void cmdClearDepthStencilImage(CommandBuffer commandBuffer, Image image, ImageLayout imageLayout, const ClearDepthStencilValue& pDepthStencil, Span<const ImageSubresourceRange> pRanges){ VKPP_DISPATCH(vkCmdClearDepthStencilImage((VkCommandBuffer)(commandBuffer), (VkImage)(image), static_cast<VkImageLayout>(imageLayout), (const VkClearDepthStencilValue*)(&pDepthStencil), pRanges.size(), (const VkImageSubresourceRange*)(pRanges.data()))); }
inline void cmdClearAttachments(CommandBuffer commandBuffer, uint32_t attachmentCount, const ClearAttachment& pAttachments, uint32_t rectCount, const ClearRect& pRects){ return VKPP_DISPATCH(vkCmdClearAttachments((VkCommandBuffer)(commandBuffer), attachmentCount, (const VkClearAttachment*)(&pAttachments), rectCount, (const VkClearRect*)(&pRects))); }
inline void cmdClearAttachments(CommandBuffer commandBuffer, Span<const ClearAttachment> pAttachments, Span<const ClearRect> pRects){ VKPP_DISPATCH(vkCmdClearAttachments((VkCommandBuffer)(commandBuffer), pAttachments.size(), (const VkClearAttachment*)(pAttachments.data()), pRects.size(), (const VkClearRect*)(pRects.data()))); }
inline void cmdResolveImage(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageResolve& pRegions){ return VKPP_DISPATCH(vkCmdResolveImage((VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), regionCount, (const VkImageResolve*)(&pRegions))); }
inline void cmdResolveImage(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, Span<const ImageResolve> pRegions){ VKPP_DISPATCH(vkCmdResolveImage((VkCommandBuffer)(commandBuffer), (VkImage)(srcImage), static_cast<VkImageLayout>(srcImageLayout), (VkImage)(dstImage), static_cast<VkImageLayout>(dstImageLayout), pRegions.size(), (const VkImageResolve*)(pRegions.data()))); }
inline void cmdSetEvent(CommandBuffer commandBuffer, Event event, PipelineStageFlags stageMask){ return VKPP_DISPATCH(vkCmdSetEvent((VkCommandBuffer)(commandBuffer), (VkEvent)(event), static_cast<VkPipelineStageFlags>(stageMask))); }
inline void cmdResetEvent(CommandBuffer commandBuffer, Event event, PipelineStageFlags stageMask){ return VKPP_DISPATCH(vkCmdResetEvent((VkCommandBuffer)(commandBuffer), (VkEvent)(event), static_cast<VkPipelineStageFlags>(stageMask))); }
inline void cmdWaitEvents(CommandBuffer commandBuffer, uint32_t eventCount, const Event& pEvents, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const MemoryBarrier& pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const BufferMemoryBarrier& pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const ImageMemoryBarrier& pImageMemoryBarriers){ return VKPP_DISPATCH(vkCmdWaitEvents((VkCommandBuffer)(commandBuffer), eventCount, (const VkEvent*)(&pEvents), static_cast<VkPipelineStageFlags>(srcStageMask), static_cast<VkPipelineStageFlags>(dstStageMask), memoryBarrierCount, (const VkMemoryBarrier*)(&pMemoryBarriers), bufferMemoryBarrierCount, (const VkBufferMemoryBarrier*)(&pBufferMemoryBarriers), imageMemoryBarrierCount, (const VkImageMemoryBarrier*)(&pImageMemoryBarriers))); }
inline void cmdWaitEvents(CommandBuffer commandBuffer, Span<const Event> pEvents, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, Span<const MemoryBarrier> pMemoryBarriers, Span<const BufferMemoryBarrier> pBufferMemoryBarriers, Span<const ImageMemoryBarrier> pImageMemoryBarriers){ VKPP_DISPATCH(vkCmdWaitEvents((VkCommandBuffer)(commandBuffer), pEvents.size(), (const VkEvent*)(pEvents.data()), static_cast<VkPipelineStageFlags>(srcStageMask), static_cast<VkPipelineStageFlags>(dstStageMask), pMemoryBarriers.size(), (const VkMemoryBarrier*)(pMemoryBarriers.data()), pBufferMemoryBarriers.size(), (const VkBufferMemoryBarrier*)(pBufferMemoryBarriers.data()), pImageMemoryBarriers.size(), (const VkImageMemoryBarrier*)(pImageMemoryBarriers.data()))); }
inline void cmdPipelineBarrier(CommandBuffer commandBuffer, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, DependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const MemoryBarrier& pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const BufferMemoryBarrier& pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const ImageMemoryBarrier& pImageMemoryBarriers){ return VKPP_DISPATCH(vkCmdPipelineBarrier((VkCommandBuffer)(commandBuffer), static_cast<VkPipelineStageFlags>(srcStageMask), static_cast<VkPipelineStageFlags>(dstStageMask), static_cast<VkDependencyFlags>(dependencyFlags), memoryBarrierCount, (const VkMemoryBarrier*)(&pMemoryBarriers), bufferMemoryBarrierCount, (const VkBufferMemoryBarrier*)(&pBufferMemoryBarriers), imageMemoryBarrierCount, (const VkImageMemoryBarrier*)(&pImageMemoryBarriers))); }
inline void cmdPipelineBarrier(CommandBuffer commandBuffer, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, DependencyFlags dependencyFlags, Span<const MemoryBarrier> pMemoryBarriers, Span<const BufferMemoryBarrier> pBufferMemoryBarriers, Span<const ImageMemoryBarrier> pImageMemoryBarriers){ VKPP_DISPATCH(vkCmdPipelineBarrier((VkCommandBuffer)(commandBuffer), static_cast<VkPipelineStageFlags>(srcStageMask), static_cast<VkPipelineStageFlags>(dstStageMask), static_cast<VkDependencyFlags>(dependencyFlags), pMemoryBarriers.size(), (const VkMemoryBarrier*)(pMemoryBarriers.data()), pBufferMemoryBarriers.size(), (const VkBufferMemoryBarrier*)(pBufferMemoryBarriers.data()), pImageMemoryBarriers.size(), (const VkImageMemoryBarrier*)(pImageMemoryBarriers.data()))); }
inline void cmdBeginQuery(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t query, QueryControlFlags flags = {}){ return VKPP_DISPATCH(vkCmdBeginQuery((VkCommandBuffer)(commandBuffer), (VkQueryPool)(queryPool), query, static_cast<VkQueryControlFlags>(flags))); }
inline void cmdEndQuery(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t query){ return VKPP_DISPATCH(vkCmdEndQuery((VkCommandBuffer)(commandBuffer), (VkQueryPool)(queryPool), query)); }
inline void cmdResetQueryPool(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount){ return VKPP_DISPATCH(vkCmdResetQueryPool((VkCommandBuffer)(commandBuffer), (VkQueryPool)(queryPool), firstQuery, queryCount)); }
inline void cmdWriteTimestamp(CommandBuffer commandBuffer, PipelineStageBits pipelineStage, QueryPool queryPool, uint32_t query){ return VKPP_DISPATCH(vkCmdWriteTimestamp((VkCommandBuffer)(commandBuffer), static_cast<VkPipelineStageFlagBits>(pipelineStage), (VkQueryPool)(queryPool), query)); }
inline void cmdCopyQueryPoolResults(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize stride, QueryResultFlags flags = {}){ return VKPP_DISPATCH(vkCmdCopyQueryPoolResults((VkCommandBuffer)(commandBuffer), (VkQueryPool)(queryPool), firstQuery, queryCount, (VkBuffer)(dstBuffer), dstOffset, stride, static_cast<VkQueryResultFlags>(flags))); }
inline void cmdPushConstants(CommandBuffer commandBuffer, PipelineLayout layout, ShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues){ return VKPP_DISPATCH(vkCmdPushConstants((VkCommandBuffer)(commandBuffer), (VkPipelineLayout)(layout), static_cast<VkShaderStageFlags>(stageFlags), offset, size, (const void*)(pValues))); }
inline void cmdPushConstants(CommandBuffer commandBuffer, PipelineLayout layout, ShaderStageFlags stageFlags, uint32_t offset, Span<const uint8_t> pValues){ VKPP_DISPATCH(vkCmdPushConstants((VkCommandBuffer)(commandBuffer), (VkPipelineLayout)(layout), static_cast<VkShaderStageFlags>(stageFlags), offset, pValues.size(), (const void*)(pValues.data()))); }
inline void cmdBeginRenderPass(CommandBuffer commandBuffer, const RenderPassBeginInfo& pRenderPassBegin, SubpassContents contents){ return VKPP_DISPATCH(vkCmdBeginRenderPass((VkCommandBuffer)(commandBuffer), (const VkRenderPassBeginInfo*)(&pRenderPassBegin), static_cast<VkSubpassContents>(contents))); }
inline void cmdNextSubpass(CommandBuffer commandBuffer, SubpassContents contents){ return VKPP_DISPATCH(vkCmdNextSubpass((VkCommandBuffer)(commandBuffer), static_cast<VkSubpassContents>(contents))); }
inline void cmdEndRenderPass(CommandBuffer commandBuffer){ return VKPP_DISPATCH(vkCmdEndRenderPass((VkCommandBuffer)(commandBuffer))); }
inline void cmdExecuteCommands(CommandBuffer commandBuffer, uint32_t commandBufferCount, const CommandBuffer& pCommandBuffers){ return VKPP_DISPATCH(vkCmdExecuteCommands((VkCommandBuffer)(commandBuffer), commandBufferCount, (const VkCommandBuffer*)(&pCommandBuffers))); }
inline void cmdExecuteCommands(CommandBuffer commandBuffer, Span<const CommandBuffer> pCommandBuffers){ VKPP_DISPATCH(vkCmdExecuteCommands((VkCommandBuffer)(commandBuffer), pCommandBuffers.size(), (const VkCommandBuffer*)(pCommandBuffers.data()))); }

#undef VEC_FUNC
#undef VEC_FUNC_VOID
#undef VEC_FUNC_RET
#undef VEC_FUNC_RET_VOID

} // namespace vk

// The specification (vk.xml) itself is published under the following license:

// Copyright (c) 2015-2019 The Khronos Group Inc.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 
// ---- Exceptions to the Apache 2.0 License: ----
// 
// As an exception, if you use this Software to generate code and portions of
// this Software are embedded into the generated code as a result, you may
// redistribute such product without providing attribution as would otherwise
// be required by Sections 4(a), 4(b) and 4(d) of the License.
// 
// In addition, if you combine or link code generated by this Software with
// software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
// ("`Combined Software`") and if a court of competent jurisdiction determines
// that the patent provision (Section 3), the indemnity provision (Section 9)
// or other Section of the License conflicts with the conditions of the
// applicable GPL or LGPL license, you may retroactively and prospectively
// choose to deem waived or otherwise exclude such Section(s) of the License,
// but only in their entirety and only with respect to the Combined Software.
    